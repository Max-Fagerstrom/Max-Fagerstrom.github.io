<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Iterum</title><meta name="description" content="Iterum is a real time strategy game made by Evergreen IT AB. I’ve worked on this game during my graduation project as well as my&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://max-fagerstrom.github.io/iterum.html"><link rel="alternate" type="application/atom+xml" href="https://max-fagerstrom.github.io/feed.xml"><link rel="alternate" type="application/json" href="https://max-fagerstrom.github.io/feed.json"><meta property="og:title" content="Iterum"><meta property="og:site_name" content="Max Fagerström"><meta property="og:description" content="Iterum is a real time strategy game made by Evergreen IT AB. I’ve worked on this game during my graduation project as well as my&hellip;"><meta property="og:url" content="https://max-fagerstrom.github.io/iterum.html"><meta property="og:type" content="article"><link rel="preload" href="https://max-fagerstrom.github.io/assets/dynamic/fonts/jetbrainsmono/jetbrainsmono.woff2" as="font" type="font/woff2" crossorigin><link rel="preload" href="https://max-fagerstrom.github.io/assets/dynamic/fonts/jetbrainsmono/jetbrainsmono-italic.woff2" as="font" type="font/woff2" crossorigin><link rel="stylesheet" href="https://max-fagerstrom.github.io/assets/css/style.css?v=aca50f00328abb7b6ee02461f2cce3be"><link rel="stylesheet" href="https://max-fagerstrom.github.io/assets/css/photoswipe.css?v=366561c4c503c68e3af3389ac4d7fb8e"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://max-fagerstrom.github.io/iterum.html"},"headline":"Iterum","datePublished":"2024-11-26T14:40+01:00","dateModified":"2024-11-26T16:29+01:00","description":"Iterum is a real time strategy game made by Evergreen IT AB. I’ve worked on this game during my graduation project as well as my&hellip;","author":{"@type":"Person","name":"Max Fagerström","url":"https://max-fagerstrom.github.io/authors/max-fagerstroem/"},"publisher":{"@type":"Organization","name":"Max Fagerström"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="page-template"><div class="container container--center"><header class="header"><div class="header__logo"><a class="logo" href="https://max-fagerstrom.github.io/">Max Fagerström</a></div><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu" aria-haspopup="true" aria-expanded="false"><span class="navbar__toggle-box"><span class="navbar__toggle-inner">Menu</span></span></button><ul class="navbar__menu"><li><a href="https://max-fagerstrom.github.io/" target="_self">Home</a></li><li><a href="https://max-fagerstrom.github.io/demos.html" target="_self">Demos</a></li><li><span class="is-separator">|</span></li><li><a href="https://max-fagerstrom.github.io/portfolio.html" target="_self">Portfolio</a></li><li><a href="https://github.com/Max-Fagerstrom" target="_blank">GitHub</a></li></ul></nav></header><main class="content page"><article class="post"><header><h1 class="post__title">Iterum</h1></header><div class="post__entry"><p><span style="font-weight: 400;">Iterum is a real time strategy game made by Evergreen IT AB. I’ve worked on this game during my graduation project as well as my internship. The game is implemented using the custom Evergreen game engine, written in C++. My work mostly pertains to graphics programming, using OpenGL and GLSL. I’ve worked on terrain rendering, water rendering, instancing and cloud shadow rendering, as well as some smaller tasks and bugfixes.</span></p><p><a href="https://store.steampowered.com/app/2069820/Iterum/" target="_blank" rel="noopener noreferrer">Iterum Steam page</a></p><hr><h2><span style="font-weight: 400;">Terrain rendering</span></h2><p><span style="font-weight: 400;">My work on terrain rendering began during my graduation project, with refinements implemented later during my internship. The game initially had very “blocky” terrain texturing. To make it look better I implemented noise and blending between the different textures on the world mesh, and texture variations. This required changes to data structures sent to the GPU as well as changes in the shaders, adding noise and smooth blending functions.</span></p><div class="gallery-wrapper"><div class="gallery" data-is-empty="false" data-translation="Add images" data-columns="2"><figure class="gallery__item"><a href="https://max-fagerstrom.github.io/media/posts/6//gallery/initial.png" data-size="612x589"><img loading="lazy" src="https://max-fagerstrom.github.io/media/posts/6//gallery/initial-thumbnail.png" alt="" width="612" height="589"></a><figcaption>Before</figcaption></figure><figure class="gallery__item"><a href="https://max-fagerstrom.github.io/media/posts/6//gallery/final.png" data-size="1143x703"><img loading="lazy" src="https://max-fagerstrom.github.io/media/posts/6//gallery/final-thumbnail.png" alt="" width="768" height="472"></a><figcaption>After</figcaption></figure><figure class="gallery__item"><a href="https://max-fagerstrom.github.io/media/posts/6/gallery/Skaermbild-2024-11-26-162659.png" data-size="935x691"><img loading="lazy" src="https://max-fagerstrom.github.io/media/posts/6/gallery/Skaermbild-2024-11-26-162659-thumbnail.png" alt="" width="768" height="568"></a></figure><figure class="gallery__item"><a href="https://max-fagerstrom.github.io/media/posts/6/gallery/Skaermbild-2024-11-26-162713.png" data-size="767x717"><img loading="lazy" src="https://max-fagerstrom.github.io/media/posts/6/gallery/Skaermbild-2024-11-26-162713-thumbnail.png" alt="" width="767" height="717"></a></figure></div></div><p><span style="font-weight: 400;">For texture variation I implemented a tilemap based approach and worked with an artist to produce a few different varieties of textures for the different terrain types. Tiles get a random value at generation and in the fragment shader selects a texture variation based on this value.</span></p><figure class="post__image post__image--center"><img loading="lazy" src="https://max-fagerstrom.github.io/media/posts/6/lowres_variation.png" alt="" width="899" height="178" sizes="(min-width: 920px) 703px, (min-width: 700px) calc(82vw - 35px), calc(100vw - 81px)" srcset="https://max-fagerstrom.github.io/media/posts/6/responsive/lowres_variation-xs.png 300w, https://max-fagerstrom.github.io/media/posts/6/responsive/lowres_variation-sm.png 480w, https://max-fagerstrom.github.io/media/posts/6/responsive/lowres_variation-md.png 768w, https://max-fagerstrom.github.io/media/posts/6/responsive/lowres_variation-lg.png 1024w"></figure><div class="gallery-wrapper"><div class="gallery" data-is-empty="false" data-translation="Add images" data-columns="3"><figure class="gallery__item"><a href="https://max-fagerstrom.github.io/media/posts/6/gallery/variation.png" data-size="871x651"><img loading="lazy" src="https://max-fagerstrom.github.io/media/posts/6/gallery/variation-thumbnail.png" alt="" width="768" height="574"></a><figcaption>Variations as rendered in world</figcaption></figure><figure class="gallery__item"><a href="https://max-fagerstrom.github.io/media/posts/6/gallery/noise.png" data-size="934x610"><img loading="lazy" src="https://max-fagerstrom.github.io/media/posts/6/gallery/noise-thumbnail.png" alt="" width="768" height="502"></a><figcaption>Work in progress texture blending</figcaption></figure></div></div><hr><h2><span style="font-weight: 400;">Water rendering</span></h2><p><span style="font-weight: 400;">For water rendering I implemented a wave animation close to shore tiles, also i fixed a bug where the water would show up untextured on some GPUs.</span></p><div class="gallery-wrapper"><div class="gallery" data-is-empty="false" data-translation="Add images" data-columns="3"><figure class="gallery__item"><a href="https://max-fagerstrom.github.io/media/posts/6/gallery/Skaermbild-2024-11-07-122653-2.png" data-size="1456x1023"><img loading="lazy" src="https://max-fagerstrom.github.io/media/posts/6/gallery/Skaermbild-2024-11-07-122653-2-thumbnail.png" alt="" width="768" height="540"></a></figure><figure class="gallery__item"><a href="https://max-fagerstrom.github.io/media/posts/6/gallery/345848748-e2ceeb32-57e8-41da-9356-68c7986269c8.png" data-size="1179x822"><img loading="lazy" src="https://max-fagerstrom.github.io/media/posts/6/gallery/345848748-e2ceeb32-57e8-41da-9356-68c7986269c8-thumbnail.png" alt="" width="768" height="535"></a></figure><figure class="gallery__item"><a href="https://max-fagerstrom.github.io/media/posts/6/gallery/345848706-6e1bf66c-bc19-4a44-9c28-e3529b9a73fe.png" data-size="1177x791"><img loading="lazy" src="https://max-fagerstrom.github.io/media/posts/6/gallery/345848706-6e1bf66c-bc19-4a44-9c28-e3529b9a73fe-thumbnail.png" alt="" width="768" height="516"></a><figcaption>Water broken on Nvidia GPU's</figcaption></figure></div></div><p><span style="font-weight: 400;">This was due to the Nvidia shader compiler optimizing out uniforms that it thinks are unused, or do not contribute to the final color value. The waves are implemented by combining noise functions in the fragment shader.</span></p><figure class="post__video"><video loading="lazy" width="300" height="150" controls="controls" data-mce-fragment="1"><source src="media/water1.mp4" type="video/mp4"></video></figure><p><span style="font-weight: 400;">The wave positioning is done by generating a low res texture where each tile is given a pixel, I then rely on texture filtering to get smooth values that I can use to identify shorelines in the shader.</span></p><hr><h2><span style="font-weight: 400;">Cloud shadows</span></h2><p><span style="font-weight: 400;">The existing implementation for cloud shadows were CPU based, a texture is generated on the CPU and buffered into a texture. To iterate on this I implemented a system where clouds are simulated as entities in the world, and then during a special shadow render pass we render the shadows of the clouds only.</span></p><div class="gallery-wrapper"><div class="gallery" data-is-empty="false" data-translation="Add images" data-columns="3"><figure class="gallery__item"><a href="https://max-fagerstrom.github.io/media/posts/6/gallery/Skaermbild-2024-09-04-091922.png" data-size="717x574"><img loading="lazy" src="https://max-fagerstrom.github.io/media/posts/6/gallery/Skaermbild-2024-09-04-091922-thumbnail.png" alt="" width="717" height="574"></a><figcaption>Shadows of clouds, work in progress</figcaption></figure><figure class="gallery__item"><a href="https://max-fagerstrom.github.io/media/posts/6/gallery/Skaermbild-2024-09-04-092401.png" data-size="796x596"><img loading="lazy" src="https://max-fagerstrom.github.io/media/posts/6/gallery/Skaermbild-2024-09-04-092401-thumbnail.png" alt="" width="768" height="575"></a></figure><figure class="gallery__item"><a href="https://max-fagerstrom.github.io/media/posts/6/gallery/Skaermbild-2024-09-09-152902.png" data-size="467x389"><img loading="lazy" src="https://max-fagerstrom.github.io/media/posts/6/gallery/Skaermbild-2024-09-09-152902-thumbnail.png" alt="" width="467" height="389"></a><figcaption>Noisy edge prototyping</figcaption></figure></div></div><p><span style="font-weight: 400;">The clouds themselves are never rendered. I implemented a pooling system for cloud entities to minimize allocation / deallocation.</span></p><figure class="post__video"><video loading="lazy" width="300" height="150" controls="controls" data-mce-fragment="1"><source src="media/clouds1.mp4" type="video/mp4"></video></figure><p>Early iteration of cloud pooling and spawning.</p><div class="gallery-wrapper"><div class="gallery" data-is-empty="false" data-translation="Add images" data-columns="3"><figure class="gallery__item"><a href="https://max-fagerstrom.github.io/media/posts/6/gallery/Skaermbild-2024-11-26-161448.png" data-size="384x307"><img loading="lazy" src="https://max-fagerstrom.github.io/media/posts/6/gallery/Skaermbild-2024-11-26-161448-thumbnail.png" alt="" width="384" height="307"></a></figure><figure class="gallery__item"><a href="https://max-fagerstrom.github.io/media/posts/6/gallery/Skaermbild-2024-11-26-161506.png" data-size="733x558"><img loading="lazy" src="https://max-fagerstrom.github.io/media/posts/6/gallery/Skaermbild-2024-11-26-161506-thumbnail.png" alt="" width="733" height="558"></a></figure></div></div><p>During this I also implemented an alternative approach that relied entirely on noise, we decided to go with the other solution though, since it could more easily be iterated upon by others. An iteration of this is available on shadertoy <a href="https://www.shadertoy.com/view/4cffDN" target="_blank" rel="noopener noreferrer">here</a>.</p><hr><h2><span style="font-weight: 400;">Instancing</span></h2><p><span style="font-weight: 400;">The engine already had instancing implemented, but it had been turned off at some point in the past due to graphical glitches. I rewrote the way entities are collected for rendering, the way buffers are set up, and the way uniforms and arrays are sent to the GPU, and got it all up and running again. During testing, an increase of 15 fps was measured on lower end systems. While implementing this I learned a lot from reading OpenGL documentation and articles on rendering optimization. I have previously implemented instancing, but I think it was fun working on it as part of a larger project.</span></p><hr><p> </p></div></article></main><footer class="footer"><div class="footer__inner"><div class="footer__copyright"><p>© 2024 Max Fagerström</p></div></div></footer></div><script defer="defer" src="https://max-fagerstrom.github.io/assets/js/scripts.min.js?v=c2232aa7558e9517946129d2a1b8c770"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script><script defer="defer" src="https://max-fagerstrom.github.io/assets/js/photoswipe.min.js?v=017385b552f7e0d979e2e2fe6f324015"></script><script defer="defer" src="https://max-fagerstrom.github.io/assets/js/photoswipe-ui-default.min.js?v=d067f0883540b1ddda0e2c9ad1b14260"></script><script>var initPhotoSwipeFromDOM=function(gallerySelector){var parseThumbnailElements=function(el){var thumbElements=el.childNodes,numNodes=thumbElements.length,items=[],figureEl,linkEl,size,item;for(var i=0;i<numNodes;i++){figureEl=thumbElements[i];if(figureEl.nodeType!==1){continue;}
   linkEl=figureEl.children[0];size=linkEl.getAttribute('data-size').split('x');item={src:linkEl.getAttribute('href'),w:parseInt(size[0],10),h:parseInt(size[1],10)};if(figureEl.children.length>1){item.title=figureEl.children[1].innerHTML;}
   if(linkEl.children.length>0){item.msrc=linkEl.children[0].getAttribute('src');}
   item.el=figureEl;items.push(item);}
   return items;};var closest=function closest(el,fn){return el&&(fn(el)?el:closest(el.parentNode,fn));};var onThumbnailsClick=function(e){e=e||window.event;e.preventDefault?e.preventDefault():e.returnValue=false;var eTarget=e.target||e.srcElement;var clickedListItem=closest(eTarget,function(el){return(el.tagName&&el.tagName.toUpperCase()==='FIGURE');});if(!clickedListItem){return;}
   var clickedGallery=clickedListItem.parentNode,childNodes=clickedListItem.parentNode.childNodes,numChildNodes=childNodes.length,nodeIndex=0,index;for(var i=0;i<numChildNodes;i++){if(childNodes[i].nodeType!==1){continue;}
   if(childNodes[i]===clickedListItem){index=nodeIndex;break;}
   nodeIndex++;}
   if(index>=0){openPhotoSwipe(index,clickedGallery);}
   return false;};var photoswipeParseHash=function(){var hash=window.location.hash.substring(1),params={};if(hash.length<5){return params;}
   var vars=hash.split('&');for(var i=0;i<vars.length;i++){if(!vars[i]){continue;}
   var pair=vars[i].split('=');if(pair.length<2){continue;}
   params[pair[0]]=pair[1];}
   if(params.gid){params.gid=parseInt(params.gid,10);}
   return params;};var openPhotoSwipe=function(index,galleryElement,disableAnimation,fromURL){var pswpElement=document.querySelectorAll('.pswp')[0],gallery,options,items;items=parseThumbnailElements(galleryElement);options={galleryUID:galleryElement.getAttribute('data-pswp-uid'),getThumbBoundsFn:function(index){var thumbnail=items[index].el.getElementsByTagName('img')[0],pageYScroll=window.pageYOffset||document.documentElement.scrollTop,rect=thumbnail.getBoundingClientRect();return{x:rect.left,y:rect.top+pageYScroll,w:rect.width};},
   mainClass:'pswp--dark',
   preload: [1,2],
   hideAnimationDuration:200,
   showAnimationDuration:0,
   bgOpacity: 0.7,
   showHideOpacity:true,
   closeOnScroll: true,
   arrowKeys: true,
   closeEl: true,
   captionEl: true,
   fullscreenEl: true,
   zoomEl: true,
   shareEl: true,
   counterEl: true,
   arrowEl: true,
   preloaderEl: true
   };if(fromURL){if(options.galleryPIDs){for(var j=0;j<items.length;j++){if(items[j].pid==index){options.index=j;break;}}}else{options.index=parseInt(index,10)-1;}}else{options.index=parseInt(index,10);}
   if(isNaN(options.index)){return;}
   if(disableAnimation){options.showAnimationDuration=0;}
   gallery=new PhotoSwipe(pswpElement,PhotoSwipeUI_Default,items,options);gallery.init();gallery.options.escKey=true;};var galleryElements=document.querySelectorAll(gallerySelector);for(var i=0,l=galleryElements.length;i<l;i++){galleryElements[i].setAttribute('data-pswp-uid',i+1);galleryElements[i].onclick=onThumbnailsClick;}
   var hashData=photoswipeParseHash();if(hashData.pid&&hashData.gid){openPhotoSwipe(hashData.pid,galleryElements[hashData.gid-1],true,true);}};window.addEventListener('load', function () {initPhotoSwipeFromDOM('.gallery');}, false);</script><div class="pswp" tabindex="-1" role="dialog" aria-hidden="true"><div class="pswp__bg"></div><div class="pswp__scroll-wrap"><div class="pswp__container"><div class="pswp__item"></div><div class="pswp__item"></div><div class="pswp__item"></div></div><div class="pswp__ui pswp__ui--hidden"><div class="pswp__top-bar"><div class="pswp__counter"></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button><button class="pswp__button pswp__button--share" title="Share"></button><button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button><button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class="pswp__preloader"><div class="pswp__preloader__icn"><div class="pswp__preloader__cut"><div class="pswp__preloader__donut"></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class="pswp__share-tooltip"></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button><button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class="pswp__caption"><div class="pswp__caption__center"></div></div></div></div></div></body></html>